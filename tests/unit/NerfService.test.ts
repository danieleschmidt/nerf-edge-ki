/**\n * Unit tests for NerfService\n */\n\nimport { NerfService, ModelOptimizationOptions, TrainingConfig } from '../../src/services/NerfService';\nimport { NerfModel } from '../../src/core/NerfModel';\nimport { NerfScene } from '../../src/core/NerfScene';\n\ndescribe('NerfService', () => {\n  let service: NerfService;\n\n  beforeEach(() => {\n    service = new NerfService();\n  });\n\n  afterEach(() => {\n    service.dispose();\n  });\n\n  describe('model loading', () => {\n    it('should load model from ArrayBuffer', async () => {\n      // Arrange\n      const mockData = new ArrayBuffer(1024);\n      const modelId = 'test-model';\n\n      // Act\n      const model = await service.loadModel(mockData, modelId);\n\n      // Assert\n      expect(model).toBeInstanceOf(NerfModel);\n      expect(model.isModelLoaded()).toBe(true);\n    });\n\n    it('should cache loaded models', async () => {\n      // Arrange\n      const mockData = new ArrayBuffer(1024);\n      const modelId = 'cached-model';\n\n      // Act\n      const model1 = await service.loadModel(mockData, modelId);\n      const model2 = await service.loadModel(mockData, modelId);\n\n      // Assert\n      expect(model1).toBe(model2); // Same instance from cache\n    });\n\n    it('should handle URL loading', async () => {\n      // Arrange\n      const mockUrl = 'https://example.com/model.nerf';\n      \n      // Mock fetch\n      global.fetch = jest.fn().mockResolvedValue({\n        ok: true,\n        arrayBuffer: () => Promise.resolve(new ArrayBuffer(2048))\n      }) as jest.Mock;\n\n      // Act\n      const model = await service.loadModel(mockUrl);\n\n      // Assert\n      expect(model).toBeInstanceOf(NerfModel);\n      expect(fetch).toHaveBeenCalledWith(mockUrl);\n    });\n\n    it('should throw error for failed URL loading', async () => {\n      // Arrange\n      const badUrl = 'https://example.com/nonexistent.nerf';\n      \n      global.fetch = jest.fn().mockResolvedValue({\n        ok: false,\n        statusText: 'Not Found'\n      }) as jest.Mock;\n\n      // Act & Assert\n      await expect(service.loadModel(badUrl)).rejects.toThrow('Failed to load model');\n    });\n  });\n\n  describe('model optimization', () => {\n    let baseModel: NerfModel;\n    const modelId = 'optimization-test';\n\n    beforeEach(async () => {\n      const mockData = new ArrayBuffer(4096);\n      baseModel = await service.loadModel(mockData, modelId);\n    });\n\n    it('should optimize model for Vision Pro', async () => {\n      // Arrange\n      const options: ModelOptimizationOptions = {\n        targetDevice: 'vision-pro',\n        maxLatency: 4.2,\n        maxMemory: 1024,\n        minQuality: 0.92,\n        enableQuantization: true,\n        enablePruning: false\n      };\n\n      // Act\n      const optimizedModel = await service.optimizeModel(modelId, options);\n\n      // Assert\n      expect(optimizedModel).toBeInstanceOf(NerfModel);\n      expect(optimizedModel.getMemoryUsage()).toBeLessThanOrEqual(options.maxMemory * 1024 * 1024);\n    });\n\n    it('should cache optimized models', async () => {\n      // Arrange\n      const options: ModelOptimizationOptions = {\n        targetDevice: 'iphone-15-pro',\n        maxLatency: 4.8,\n        maxMemory: 512,\n        minQuality: 0.88,\n        enableQuantization: true,\n        enablePruning: true\n      };\n\n      // Act\n      const optimized1 = await service.optimizeModel(modelId, options);\n      const optimized2 = await service.optimizeModel(modelId, options);\n\n      // Assert\n      expect(optimized1).toBe(optimized2); // Same instance from cache\n    });\n\n    it('should get optimization recommendations', () => {\n      // Act\n      const recommendations = service.getOptimizationRecommendations('web');\n\n      // Assert\n      expect(recommendations).toHaveProperty('targetDevice', 'web');\n      expect(recommendations).toHaveProperty('maxLatency');\n      expect(recommendations).toHaveProperty('maxMemory');\n      expect(recommendations).toHaveProperty('minQuality');\n    });\n  });\n\n  describe('model training', () => {\n    it('should train model from point cloud data', async () => {\n      // Arrange\n      const pointCloudData = new ArrayBuffer(8192);\n      const config: TrainingConfig = {\n        iterations: 100,\n        learningRate: 0.001,\n        batchSize: 4096,\n        useNeuralEngine: false,\n        checkpoint_interval: 50\n      };\n      \n      const progressUpdates: number[] = [];\n      const progressCallback = (progress: number) => {\n        progressUpdates.push(progress);\n      };\n\n      // Act\n      const trainedModel = await service.trainModel(pointCloudData, config, progressCallback);\n\n      // Assert\n      expect(trainedModel).toBeInstanceOf(NerfModel);\n      expect(trainedModel.isModelLoaded()).toBe(true);\n      expect(progressUpdates.length).toBeGreaterThan(0);\n      expect(progressUpdates[progressUpdates.length - 1]).toBe(1.0);\n    });\n\n    it('should handle training timeout', async () => {\n      // Arrange\n      const pointCloudData = new ArrayBuffer(1024);\n      const config: TrainingConfig = {\n        iterations: 10000, // Very high iterations\n        learningRate: 0.001,\n        batchSize: 4096,\n        useNeuralEngine: false,\n        checkpoint_interval: 1000\n      };\n\n      // Act & Assert\n      await expect(service.trainModel(pointCloudData, config)).rejects.toThrow('Training timeout');\n    });\n  });\n\n  describe('scene management', () => {\n    let models: NerfModel[];\n    const modelIds = ['model1', 'model2', 'model3'];\n\n    beforeEach(async () => {\n      models = [];\n      for (const id of modelIds) {\n        const mockData = new ArrayBuffer(2048);\n        const model = await service.loadModel(mockData, id);\n        models.push(model);\n      }\n    });\n\n    it('should create scene from multiple models', () => {\n      // Act\n      const scene = service.createScene(modelIds, {\n        name: 'Test Scene',\n        lighting: {\n          ambient: [0.1, 0.1, 0.1]\n        }\n      });\n\n      // Assert\n      expect(scene).toBeInstanceOf(NerfScene);\n      expect(scene.getModels()).toHaveLength(modelIds.length);\n      expect(scene.getConfig().name).toBe('Test Scene');\n    });\n\n    it('should handle missing models in scene creation', () => {\n      // Arrange\n      const invalidModelIds = ['model1', 'nonexistent', 'model3'];\n\n      // Act\n      const scene = service.createScene(invalidModelIds);\n\n      // Assert\n      expect(scene.getModels()).toHaveLength(2); // Only valid models\n    });\n  });\n\n  describe('model analysis', () => {\n    let model: NerfModel;\n    const modelId = 'analysis-test';\n\n    beforeEach(async () => {\n      const mockData = new ArrayBuffer(3072);\n      model = await service.loadModel(mockData, modelId);\n    });\n\n    it('should analyze model quality and performance', async () => {\n      // Act\n      const metrics = await service.analyzeModel(modelId);\n\n      // Assert\n      expect(metrics).toHaveProperty('psnr');\n      expect(metrics).toHaveProperty('ssim');\n      expect(metrics).toHaveProperty('lpips');\n      expect(metrics).toHaveProperty('inferenceTime');\n      expect(metrics).toHaveProperty('memoryUsage');\n      expect(metrics).toHaveProperty('modelSize');\n      \n      expect(metrics.psnr).toBeGreaterThan(0);\n      expect(metrics.ssim).toBeGreaterThan(0);\n      expect(metrics.ssim).toBeLessThanOrEqual(1);\n    });\n\n    it('should validate model against requirements', async () => {\n      // Arrange\n      const requirements = {\n        psnr: 25.0,\n        ssim: 0.9,\n        inferenceTime: 10.0,\n        memoryUsage: 100 // MB\n      };\n\n      // Act\n      const isValid = await service.validateModel(modelId, requirements);\n\n      // Assert\n      expect(typeof isValid).toBe('boolean');\n    });\n\n    it('should throw error for non-existent model analysis', async () => {\n      // Act & Assert\n      await expect(service.analyzeModel('nonexistent')).rejects.toThrow('not found');\n    });\n  });\n\n  describe('cache management', () => {\n    beforeEach(async () => {\n      // Load some test models\n      for (let i = 0; i < 3; i++) {\n        const mockData = new ArrayBuffer(1024 * (i + 1));\n        await service.loadModel(mockData, `cache-test-${i}`);\n      }\n    });\n\n    it('should provide cache statistics', () => {\n      // Act\n      const stats = service.getCacheStats();\n\n      // Assert\n      expect(stats).toHaveProperty('totalModels');\n      expect(stats).toHaveProperty('totalMemory');\n      expect(stats).toHaveProperty('optimizedVariants');\n      expect(stats).toHaveProperty('cacheHitRate');\n      \n      expect(stats.totalModels).toBeGreaterThan(0);\n      expect(stats.totalMemory).toBeGreaterThan(0);\n    });\n\n    it('should clear cache when requested', () => {\n      // Act\n      service.clearCache();\n      const stats = service.getCacheStats();\n\n      // Assert\n      expect(stats.totalModels).toBe(0);\n      expect(stats.totalMemory).toBe(0);\n    });\n  });\n\n  describe('resource management', () => {\n    it('should dispose resources properly', async () => {\n      // Arrange\n      const mockData = new ArrayBuffer(1024);\n      await service.loadModel(mockData, 'dispose-test');\n\n      // Act\n      service.dispose();\n      const stats = service.getCacheStats();\n\n      // Assert\n      expect(stats.totalModels).toBe(0);\n    });\n\n    it('should handle multiple dispose calls', () => {\n      // Act & Assert\n      expect(() => {\n        service.dispose();\n        service.dispose();\n      }).not.toThrow();\n    });\n  });\n});