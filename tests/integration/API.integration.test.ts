/**\n * Integration tests for NeRF API\n */\n\nimport { NerfAPI, APIResponse } from '../../src/api/NerfAPI';\nimport { NerfRenderer } from '../../src/rendering/NerfRenderer';\nimport { ModelOptimizationOptions, TrainingConfig } from '../../src/services/NerfService';\nimport '../../web/tests/setup';\n\ndescribe('NeRF API Integration', () => {\n  let api: NerfAPI;\n  let renderer: NerfRenderer;\n\n  beforeAll(async () => {\n    // Initialize API with test configuration\n    api = new NerfAPI({\n      enableCORS: true,\n      maxRequestSize: 10 * 1024 * 1024, // 10MB for tests\n      rateLimit: {\n        windowMs: 60 * 1000,\n        maxRequests: 1000 // High limit for tests\n      }\n    });\n    \n    await api.initialize();\n    \n    // Setup renderer\n    renderer = new NerfRenderer({\n      targetFPS: 60,\n      maxResolution: [800, 600],\n      foveatedRendering: false,\n      memoryLimit: 512,\n      powerMode: 'balanced'\n    });\n    \n    api.setRenderer(renderer);\n  });\n\n  afterAll(() => {\n    api.dispose();\n    renderer.dispose();\n  });\n\n  describe('Model Management API', () => {\n    let testModelId: string;\n\n    describe('Model Creation', () => {\n      it('should create a new model successfully', async () => {\n        // Arrange\n        const modelData = new ArrayBuffer(2048);\n        const request = {\n          name: 'Test Model',\n          data: modelData,\n          quality: 'medium' as const,\n          tags: ['test', 'integration'],\n          metadata: {\n            description: 'Integration test model',\n            version: '1.0.0'\n          }\n        };\n\n        // Act\n        const response = await api.createModel(request);\n\n        // Assert\n        expect(response.success).toBe(true);\n        expect(response.data).toBeDefined();\n        expect(response.data!.id).toBeDefined();\n        expect(response.data!.model.name).toBe('Test Model');\n        expect(response.data!.model.quality).toBe('medium');\n        expect(response.data!.model.size).toBe(2048);\n        expect(response.data!.model.metrics).toBeDefined();\n        \n        testModelId = response.data!.id;\n      });\n\n      it('should reject oversized model data', async () => {\n        // Arrange\n        const oversizedData = new ArrayBuffer(20 * 1024 * 1024); // 20MB > 10MB limit\n        const request = {\n          name: 'Oversized Model',\n          data: oversizedData\n        };\n\n        // Act\n        const response = await api.createModel(request);\n\n        // Assert\n        expect(response.success).toBe(false);\n        expect(response.error).toContain('exceeds maximum size');\n      });\n    });\n\n    describe('Model Retrieval', () => {\n      it('should list models with filtering', async () => {\n        // Act\n        const response = await api.listModels({\n          tags: ['test'],\n          limit: 10\n        });\n\n        // Assert\n        expect(response.success).toBe(true);\n        expect(response.data).toBeDefined();\n        expect(response.data!.models).toBeInstanceOf(Array);\n        expect(response.data!.total).toBeGreaterThan(0);\n        expect(response.data!.models[0]).toHaveProperty('id');\n        expect(response.data!.models[0]).toHaveProperty('name');\n      });\n\n      it('should get specific model details', async () => {\n        // Act\n        const response = await api.getModel(testModelId);\n\n        // Assert\n        expect(response.success).toBe(true);\n        expect(response.data).toBeDefined();\n        expect(response.data!.id).toBe(testModelId);\n        expect(response.data!.name).toBe('Test Model');\n        expect(response.data!.tags).toContain('test');\n        expect(response.data!.metadata).toBeDefined();\n      });\n\n      it('should return error for non-existent model', async () => {\n        // Act\n        const response = await api.getModel('nonexistent-id');\n\n        // Assert\n        expect(response.success).toBe(false);\n        expect(response.error).toContain('not found');\n      });\n    });\n\n    describe('Model Updates', () => {\n      it('should update model metadata', async () => {\n        // Act\n        const response = await api.updateModel(testModelId, {\n          name: 'Updated Test Model',\n          tags: ['test', 'updated'],\n          metadata: {\n            version: '2.0.0',\n            updated: true\n          }\n        });\n\n        // Assert\n        expect(response.success).toBe(true);\n        expect(response.data!.success).toBe(true);\n\n        // Verify update\n        const getResponse = await api.getModel(testModelId);\n        expect(getResponse.data!.name).toBe('Updated Test Model');\n        expect(getResponse.data!.tags).toContain('updated');\n      });\n    });\n  });\n\n  describe('Model Operations API', () => {\n    it('should optimize model for device', async () => {\n      // Arrange\n      const options: ModelOptimizationOptions = {\n        targetDevice: 'iphone-15-pro',\n        maxLatency: 4.8,\n        maxMemory: 512,\n        minQuality: 0.88,\n        enableQuantization: true,\n        enablePruning: true\n      };\n\n      // Act\n      const response = await api.optimizeModel(testModelId, options);\n\n      // Assert\n      expect(response.success).toBe(true);\n      expect(response.data).toBeDefined();\n      expect(response.data!.optimizedId).toBeDefined();\n      expect(response.data!.metrics).toBeDefined();\n    });\n\n    it('should analyze model performance', async () => {\n      // Act\n      const response = await api.analyzeModel(testModelId);\n\n      // Assert\n      expect(response.success).toBe(true);\n      expect(response.data).toBeDefined();\n      expect(response.data!.psnr).toBeGreaterThan(0);\n      expect(response.data!.ssim).toBeGreaterThan(0);\n      expect(response.data!.ssim).toBeLessThanOrEqual(1);\n      expect(response.data!.lpips).toBeGreaterThan(0);\n      expect(response.data!.inferenceTime).toBeGreaterThan(0);\n      expect(response.data!.memoryUsage).toBeGreaterThan(0);\n    });\n\n    it('should train new model', async () => {\n      // Arrange\n      const pointCloudData = new ArrayBuffer(4096);\n      const config: TrainingConfig = {\n        iterations: 50, // Small for test\n        learningRate: 0.001,\n        batchSize: 1024,\n        useNeuralEngine: false,\n        checkpoint_interval: 25\n      };\n\n      // Act\n      const response = await api.trainModel({\n        data: pointCloudData,\n        config\n      });\n\n      // Assert\n      expect(response.success).toBe(true);\n      expect(response.data).toBeDefined();\n      expect(response.data!.modelId).toBeDefined();\n      expect(response.data!.progress).toBe(1.0);\n    });\n  });\n\n  describe('Rendering API', () => {\n    it('should render frame with model', async () => {\n      // Act\n      const response = await api.renderFrame({\n        modelId: testModelId,\n        renderOptions: {\n          cameraPosition: [0, 1.6, 3],\n          cameraRotation: [0, 0, 0, 1],\n          fieldOfView: 75,\n          near: 0.1,\n          far: 100\n        },\n        outputFormat: 'png'\n      });\n\n      // Assert\n      expect(response.success).toBe(true);\n      expect(response.data).toBeDefined();\n      expect(response.data!.imageData).toBeDefined();\n      expect(response.data!.imageData).toMatch(/^data:image/);\n      expect(response.data!.renderTime).toBeGreaterThan(0);\n    });\n\n    it('should handle missing model in render request', async () => {\n      // Act\n      const response = await api.renderFrame({\n        modelId: 'nonexistent-model',\n        renderOptions: {\n          cameraPosition: [0, 0, 3],\n          cameraRotation: [0, 0, 0, 1],\n          fieldOfView: 75,\n          near: 0.1,\n          far: 100\n        }\n      });\n\n      // Assert\n      expect(response.success).toBe(false);\n      expect(response.error).toContain('not found');\n    });\n  });\n\n  describe('Performance and Monitoring API', () => {\n    it('should get performance metrics', async () => {\n      // Act\n      const response = await api.getPerformanceMetrics();\n\n      // Assert\n      expect(response.success).toBe(true);\n      expect(response.data).toBeDefined();\n      expect(response.data!.stats).toBeDefined();\n      expect(response.data!.percentiles).toBeDefined();\n      expect(response.data!.recommendations).toBeInstanceOf(Array);\n    });\n\n    it('should run performance benchmark', async () => {\n      // Act\n      const response = await api.runBenchmark({\n        testName: 'API Integration Test',\n        duration: 0.1, // 100ms for quick test\n        modelId: testModelId\n      });\n\n      // Assert\n      expect(response.success).toBe(true);\n      expect(response.data).toBeDefined();\n      expect(response.data!.testName).toBe('API Integration Test');\n      expect(response.data!.duration).toBe(0.1);\n      expect(response.data!.averageFPS).toBeGreaterThan(0);\n      expect(response.data!.qualityScore).toBeGreaterThanOrEqual(0);\n      expect(response.data!.qualityScore).toBeLessThanOrEqual(1);\n    });\n\n    it('should get system statistics', async () => {\n      // Act\n      const response = await api.getSystemStats();\n\n      // Assert\n      expect(response.success).toBe(true);\n      expect(response.data).toBeDefined();\n      expect(response.data!.models).toBeDefined();\n      expect(response.data!.cache).toBeDefined();\n      expect(response.data!.performance).toBeDefined();\n      expect(response.data!.system).toBeDefined();\n      expect(response.data!.system.timestamp).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Error Handling and Edge Cases', () => {\n    it('should handle concurrent requests', async () => {\n      // Arrange\n      const promises = [];\n      for (let i = 0; i < 5; i++) {\n        promises.push(api.getModel(testModelId));\n      }\n\n      // Act\n      const responses = await Promise.all(promises);\n\n      // Assert\n      responses.forEach(response => {\n        expect(response.success).toBe(true);\n        expect(response.data!.id).toBe(testModelId);\n      });\n    });\n\n    it('should generate unique request IDs', async () => {\n      // Act\n      const response1 = await api.getPerformanceMetrics();\n      const response2 = await api.getPerformanceMetrics();\n\n      // Assert\n      expect(response1.requestId).toBeDefined();\n      expect(response2.requestId).toBeDefined();\n      expect(response1.requestId).not.toBe(response2.requestId);\n    });\n\n    it('should include timestamps in responses', async () => {\n      // Arrange\n      const beforeTime = Date.now();\n\n      // Act\n      const response = await api.getSystemStats();\n      const afterTime = Date.now();\n\n      // Assert\n      expect(response.timestamp).toBeGreaterThanOrEqual(beforeTime);\n      expect(response.timestamp).toBeLessThanOrEqual(afterTime);\n    });\n  });\n\n  describe('Authentication and Rate Limiting', () => {\n    let authAPI: NerfAPI;\n\n    beforeAll(async () => {\n      authAPI = new NerfAPI({\n        authentication: {\n          enabled: true,\n          apiKeyHeader: 'X-API-Key',\n          validApiKeys: ['test-key-123', 'another-key-456']\n        },\n        rateLimit: {\n          windowMs: 1000, // 1 second\n          maxRequests: 2 // Very low for testing\n        }\n      });\n      await authAPI.initialize();\n    });\n\n    afterAll(() => {\n      authAPI.dispose();\n    });\n\n    it('should authenticate valid API key', () => {\n      // Act\n      const isValid = authAPI.authenticate('test-key-123');\n\n      // Assert\n      expect(isValid).toBe(true);\n    });\n\n    it('should reject invalid API key', () => {\n      // Act\n      const isValid = authAPI.authenticate('invalid-key');\n\n      // Assert\n      expect(isValid).toBe(false);\n    });\n\n    it('should enforce rate limiting', () => {\n      // Arrange\n      const clientId = 'test-client';\n\n      // Act\n      const request1 = authAPI.rateLimit(clientId);\n      const request2 = authAPI.rateLimit(clientId);\n      const request3 = authAPI.rateLimit(clientId); // Should be blocked\n\n      // Assert\n      expect(request1).toBe(true);\n      expect(request2).toBe(true);\n      expect(request3).toBe(false);\n    });\n  });\n\n  describe('Cleanup', () => {\n    it('should delete test model', async () => {\n      // Act\n      const response = await api.deleteModel(testModelId);\n\n      // Assert\n      expect(response.success).toBe(true);\n      expect(response.data!.success).toBe(true);\n\n      // Verify deletion\n      const getResponse = await api.getModel(testModelId);\n      expect(getResponse.success).toBe(false);\n    });\n  });\n});