#!/usr/bin/env node\n\n/**\n * Comprehensive build automation script for NeRF Edge Kit\n * Handles multi-platform builds, optimizations, and deployments\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst { execSync, spawn } = require('child_process');\nconst { performance } = require('perf_hooks');\n\nclass BuildAutomation {\n  constructor() {\n    this.config = {\n      targets: ['web', 'ios', 'python'],\n      outputDir: path.resolve(__dirname, '../dist'),\n      tempDir: path.resolve(__dirname, '../.tmp'),\n      nodeModulesDir: path.resolve(__dirname, '../node_modules'),\n      parallel: true,\n      verbose: process.argv.includes('--verbose'),\n      analyze: process.argv.includes('--analyze'),\n      skipTests: process.argv.includes('--skip-tests'),\n      production: process.env.NODE_ENV === 'production' || process.argv.includes('--production')\n    };\n    \n    this.startTime = performance.now();\n    this.buildResults = {\n      web: { success: false, duration: 0, size: 0 },\n      ios: { success: false, duration: 0, size: 0 },\n      python: { success: false, duration: 0, size: 0 }\n    };\n  }\n\n  /**\n   * Main build orchestration\n   */\n  async build() {\n    console.log('🚀 Starting NeRF Edge Kit build automation...');\n    console.log(`Target: ${this.config.production ? 'Production' : 'Development'}`);\n    console.log(`Platforms: ${this.config.targets.join(', ')}`);\n    console.log('');\n\n    try {\n      // Pre-build setup\n      await this.preBuild();\n      \n      // Run builds\n      if (this.config.parallel) {\n        await this.buildParallel();\n      } else {\n        await this.buildSequential();\n      }\n      \n      // Post-build tasks\n      await this.postBuild();\n      \n      // Generate reports\n      await this.generateReports();\n      \n      this.logSuccess();\n      \n    } catch (error) {\n      this.logError(error);\n      process.exit(1);\n    }\n  }\n\n  /**\n   * Pre-build setup and validation\n   */\n  async preBuild() {\n    console.log('📋 Pre-build setup...');\n    \n    // Create directories\n    this.ensureDirectory(this.config.outputDir);\n    this.ensureDirectory(this.config.tempDir);\n    \n    // Validate environment\n    await this.validateEnvironment();\n    \n    // Install dependencies if needed\n    await this.checkDependencies();\n    \n    // Run linting\n    if (!this.config.skipTests) {\n      await this.runLinting();\n    }\n    \n    console.log('✅ Pre-build setup complete\\n');\n  }\n\n  /**\n   * Build all targets in parallel\n   */\n  async buildParallel() {\n    console.log('⚡ Building all targets in parallel...');\n    \n    const buildPromises = this.config.targets.map(target => \n      this.buildTarget(target).catch(error => {\n        console.error(`❌ ${target} build failed:`, error.message);\n        this.buildResults[target].success = false;\n        return { target, error };\n      })\n    );\n    \n    const results = await Promise.allSettled(buildPromises);\n    \n    // Check for failures\n    const failures = results.filter(r => r.status === 'rejected' || (r.value && r.value.error));\n    if (failures.length > 0) {\n      throw new Error(`${failures.length} build(s) failed`);\n    }\n  }\n\n  /**\n   * Build all targets sequentially\n   */\n  async buildSequential() {\n    console.log('🔄 Building targets sequentially...');\n    \n    for (const target of this.config.targets) {\n      await this.buildTarget(target);\n    }\n  }\n\n  /**\n   * Build specific target\n   */\n  async buildTarget(target) {\n    const startTime = performance.now();\n    console.log(`🔨 Building ${target}...`);\n    \n    try {\n      switch (target) {\n        case 'web':\n          await this.buildWeb();\n          break;\n        case 'ios':\n          await this.buildIOS();\n          break;\n        case 'python':\n          await this.buildPython();\n          break;\n        default:\n          throw new Error(`Unknown target: ${target}`);\n      }\n      \n      const duration = performance.now() - startTime;\n      this.buildResults[target].success = true;\n      this.buildResults[target].duration = duration;\n      \n      console.log(`✅ ${target} build completed in ${(duration / 1000).toFixed(2)}s`);\n      \n    } catch (error) {\n      const duration = performance.now() - startTime;\n      this.buildResults[target].duration = duration;\n      throw error;\n    }\n  }\n\n  /**\n   * Build web target with Webpack\n   */\n  async buildWeb() {\n    const env = {\n      ...process.env,\n      NODE_ENV: this.config.production ? 'production' : 'development',\n      ANALYZE_BUNDLE: this.config.analyze ? 'true' : 'false'\n    };\n    \n    // TypeScript compilation\n    await this.execCommand('npx tsc --noEmit', { env });\n    \n    // Webpack build\n    const webpackCmd = this.config.production \n      ? 'npx webpack --mode production'\n      : 'npx webpack --mode development';\n      \n    await this.execCommand(webpackCmd, { env });\n    \n    // Calculate bundle size\n    const distPath = path.join(this.config.outputDir);\n    if (fs.existsSync(distPath)) {\n      this.buildResults.web.size = this.calculateDirectorySize(distPath);\n    }\n    \n    // Run tests for web build\n    if (!this.config.skipTests) {\n      await this.execCommand('npm run test:unit -- --testPathPattern=web');\n    }\n  }\n\n  /**\n   * Build iOS target (mock - would require Xcode)\n   */\n  async buildIOS() {\n    console.log('📱 Building iOS framework (simulated)...');\n    \n    // In real implementation, would run:\n    // xcodebuild -project ios/NerfEdgeKit.xcodeproj -scheme NerfEdgeKit -configuration Release\n    \n    // Simulate build time\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    \n    // Mock framework size\n    this.buildResults.ios.size = 15 * 1024 * 1024; // 15MB\n    \n    console.log('📱 iOS framework build simulated (requires Xcode on macOS)');\n  }\n\n  /**\n   * Build Python package\n   */\n  async buildPython() {\n    console.log('🐍 Building Python package...');\n    \n    // Install Python dependencies\n    await this.execCommand('pip install -r requirements.txt');\n    \n    // Run Python tests\n    if (!this.config.skipTests) {\n      await this.execCommand('python -m pytest python/tests/', { \n        cwd: path.resolve(__dirname, '..') \n      });\n    }\n    \n    // Build wheel\n    await this.execCommand('python setup.py bdist_wheel', {\n      cwd: path.resolve(__dirname, '..')\n    });\n    \n    // Calculate package size\n    const distPath = path.resolve(__dirname, '../dist');\n    if (fs.existsSync(distPath)) {\n      const wheelFiles = fs.readdirSync(distPath).filter(f => f.endsWith('.whl'));\n      if (wheelFiles.length > 0) {\n        const wheelPath = path.join(distPath, wheelFiles[0]);\n        this.buildResults.python.size = fs.statSync(wheelPath).size;\n      }\n    }\n  }\n\n  /**\n   * Post-build tasks\n   */\n  async postBuild() {\n    console.log('🔧 Running post-build tasks...');\n    \n    // Optimize assets\n    if (this.config.production) {\n      await this.optimizeAssets();\n    }\n    \n    // Generate documentation\n    await this.generateDocs();\n    \n    // Create distribution packages\n    await this.createDistributionPackages();\n    \n    console.log('✅ Post-build tasks complete\\n');\n  }\n\n  /**\n   * Optimize assets for production\n   */\n  async optimizeAssets() {\n    console.log('🎯 Optimizing assets...');\n    \n    const distPath = this.config.outputDir;\n    \n    // Compress images (mock)\n    console.log('  📸 Compressing images...');\n    \n    // Optimize fonts (mock)\n    console.log('  🔤 Optimizing fonts...');\n    \n    // Generate service worker (mock)\n    console.log('  ⚙️  Generating service worker...');\n  }\n\n  /**\n   * Generate documentation\n   */\n  async generateDocs() {\n    console.log('📚 Generating documentation...');\n    \n    try {\n      // Generate TypeScript documentation\n      await this.execCommand('npx typedoc src --out docs/api --theme minimal');\n      console.log('  📝 TypeScript API docs generated');\n    } catch (error) {\n      console.warn('  ⚠️  Documentation generation failed:', error.message);\n    }\n  }\n\n  /**\n   * Create distribution packages\n   */\n  async createDistributionPackages() {\n    console.log('📦 Creating distribution packages...');\n    \n    const packageInfo = require('../package.json');\n    const version = packageInfo.version;\n    \n    // Create version info file\n    const versionInfo = {\n      version,\n      buildTime: new Date().toISOString(),\n      targets: this.config.targets,\n      production: this.config.production,\n      buildResults: this.buildResults\n    };\n    \n    fs.writeFileSync(\n      path.join(this.config.outputDir, 'version.json'),\n      JSON.stringify(versionInfo, null, 2)\n    );\n    \n    console.log(`  📋 Version info: ${version}`);\n  }\n\n  /**\n   * Generate build reports\n   */\n  async generateReports() {\n    console.log('📊 Generating build reports...');\n    \n    const totalDuration = performance.now() - this.startTime;\n    const totalSize = Object.values(this.buildResults).reduce((sum, result) => sum + result.size, 0);\n    \n    const report = {\n      timestamp: new Date().toISOString(),\n      totalDuration: Math.round(totalDuration),\n      totalSize: totalSize,\n      targets: this.buildResults,\n      environment: {\n        node: process.version,\n        platform: process.platform,\n        arch: process.arch,\n        production: this.config.production\n      }\n    };\n    \n    // Save detailed report\n    fs.writeFileSync(\n      path.join(this.config.outputDir, 'build-report.json'),\n      JSON.stringify(report, null, 2)\n    );\n    \n    // Generate summary\n    this.generateBuildSummary(report);\n  }\n\n  /**\n   * Generate human-readable build summary\n   */\n  generateBuildSummary(report) {\n    const summary = [\n      '# NeRF Edge Kit Build Report',\n      '',\n      `**Build Time**: ${new Date(report.timestamp).toLocaleString()}`,\n      `**Total Duration**: ${(report.totalDuration / 1000).toFixed(2)}s`,\n      `**Total Size**: ${this.formatBytes(report.totalSize)}`,\n      `**Environment**: ${report.environment.platform}/${report.environment.arch}`,\n      '',\n      '## Target Results',\n      ''\n    ];\n    \n    for (const [target, result] of Object.entries(report.targets)) {\n      const status = result.success ? '✅' : '❌';\n      const duration = (result.duration / 1000).toFixed(2);\n      const size = this.formatBytes(result.size);\n      \n      summary.push(`- **${target}**: ${status} ${duration}s (${size})`);\n    }\n    \n    fs.writeFileSync(\n      path.join(this.config.outputDir, 'BUILD_SUMMARY.md'),\n      summary.join('\\n')\n    );\n  }\n\n  /**\n   * Validate build environment\n   */\n  async validateEnvironment() {\n    const checks = [\n      { name: 'Node.js', check: () => process.version },\n      { name: 'npm', check: () => execSync('npm --version', { encoding: 'utf8' }).trim() },\n      { name: 'TypeScript', check: () => execSync('npx tsc --version', { encoding: 'utf8' }).trim() },\n      { name: 'Python', check: () => execSync('python --version', { encoding: 'utf8' }).trim() }\n    ];\n    \n    for (const { name, check } of checks) {\n      try {\n        const version = check();\n        if (this.config.verbose) {\n          console.log(`  ✅ ${name}: ${version}`);\n        }\n      } catch (error) {\n        console.warn(`  ⚠️  ${name}: Not available`);\n      }\n    }\n  }\n\n  /**\n   * Check and install dependencies\n   */\n  async checkDependencies() {\n    if (!fs.existsSync(this.config.nodeModulesDir)) {\n      console.log('📦 Installing dependencies...');\n      await this.execCommand('npm install');\n    } else if (this.config.verbose) {\n      console.log('  ✅ Dependencies already installed');\n    }\n  }\n\n  /**\n   * Run linting\n   */\n  async runLinting() {\n    console.log('🔍 Running linting...');\n    \n    try {\n      await this.execCommand('npm run lint');\n      console.log('  ✅ Linting passed');\n    } catch (error) {\n      console.warn('  ⚠️  Linting issues found');\n      // Don't fail build for linting issues in development\n      if (this.config.production) {\n        throw error;\n      }\n    }\n  }\n\n  // Utility methods\n  \n  ensureDirectory(dir) {\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true });\n    }\n  }\n  \n  calculateDirectorySize(dir) {\n    let totalSize = 0;\n    \n    const files = fs.readdirSync(dir, { withFileTypes: true });\n    for (const file of files) {\n      const filePath = path.join(dir, file.name);\n      if (file.isDirectory()) {\n        totalSize += this.calculateDirectorySize(filePath);\n      } else {\n        totalSize += fs.statSync(filePath).size;\n      }\n    }\n    \n    return totalSize;\n  }\n  \n  formatBytes(bytes) {\n    if (bytes === 0) return '0 B';\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n  \n  async execCommand(command, options = {}) {\n    return new Promise((resolve, reject) => {\n      const [cmd, ...args] = command.split(' ');\n      const child = spawn(cmd, args, {\n        stdio: this.config.verbose ? 'inherit' : 'pipe',\n        shell: true,\n        ...options\n      });\n      \n      let output = '';\n      if (!this.config.verbose) {\n        child.stdout?.on('data', (data) => {\n          output += data.toString();\n        });\n        child.stderr?.on('data', (data) => {\n          output += data.toString();\n        });\n      }\n      \n      child.on('close', (code) => {\n        if (code === 0) {\n          resolve(output);\n        } else {\n          reject(new Error(`Command failed: ${command}\\n${output}`));\n        }\n      });\n    });\n  }\n  \n  logSuccess() {\n    const totalDuration = (performance.now() - this.startTime) / 1000;\n    const successCount = Object.values(this.buildResults).filter(r => r.success).length;\n    \n    console.log('');\n    console.log('🎉 Build automation completed successfully!');\n    console.log(`⏱️  Total time: ${totalDuration.toFixed(2)}s`);\n    console.log(`✅ Successful builds: ${successCount}/${this.config.targets.length}`);\n    console.log('📊 Build reports saved to dist/ directory');\n    console.log('');\n  }\n  \n  logError(error) {\n    const totalDuration = (performance.now() - this.startTime) / 1000;\n    \n    console.log('');\n    console.log('❌ Build automation failed!');\n    console.log(`⏱️  Duration: ${totalDuration.toFixed(2)}s`);\n    console.log(`🚨 Error: ${error.message}`);\n    \n    if (this.config.verbose && error.stack) {\n      console.log('');\n      console.log('Stack trace:');\n      console.log(error.stack);\n    }\n    \n    console.log('');\n  }\n}\n\n// Run if called directly\nif (require.main === module) {\n  const automation = new BuildAutomation();\n  automation.build();\n}\n\nmodule.exports = BuildAutomation;