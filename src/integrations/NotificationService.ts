/**\n * Notification service for email, Slack, and webhook integrations\n */\n\nexport interface NotificationConfig {\n  email?: {\n    enabled: boolean;\n    smtp: {\n      host: string;\n      port: number;\n      secure: boolean;\n      user: string;\n      pass: string;\n    };\n    from: string;\n    templates: Record<string, string>;\n  };\n  slack?: {\n    enabled: boolean;\n    webhookUrl: string;\n    channel: string;\n    username: string;\n    iconEmoji: string;\n  };\n  webhooks?: {\n    enabled: boolean;\n    endpoints: Array<{\n      name: string;\n      url: string;\n      secret?: string;\n      events: string[];\n    }>;\n  };\n}\n\nexport interface NotificationEvent {\n  type: 'model_uploaded' | 'training_complete' | 'optimization_complete' | 'error' | 'performance_alert' | 'system_status';\n  title: string;\n  message: string;\n  severity: 'info' | 'warning' | 'error' | 'success';\n  data?: Record<string, any>;\n  timestamp: number;\n}\n\nexport interface EmailTemplate {\n  subject: string;\n  htmlBody: string;\n  textBody: string;\n}\n\nexport class NotificationService {\n  private config: NotificationConfig;\n  private queue: NotificationEvent[] = [];\n  private processing = false;\n\n  constructor(config: NotificationConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Send notification to all enabled channels\n   */\n  async notify(event: NotificationEvent): Promise<{\n    success: boolean;\n    results: Record<string, { success: boolean; error?: string }>;\n  }> {\n    const results: Record<string, { success: boolean; error?: string }> = {};\n    \n    // Add to queue for processing\n    this.queue.push(event);\n    \n    if (!this.processing) {\n      this.processQueue();\n    }\n\n    try {\n      // Send to email if enabled\n      if (this.config.email?.enabled) {\n        try {\n          await this.sendEmail(event);\n          results.email = { success: true };\n        } catch (error) {\n          results.email = { \n            success: false, \n            error: error instanceof Error ? error.message : 'Unknown error' \n          };\n        }\n      }\n\n      // Send to Slack if enabled\n      if (this.config.slack?.enabled) {\n        try {\n          await this.sendSlack(event);\n          results.slack = { success: true };\n        } catch (error) {\n          results.slack = { \n            success: false, \n            error: error instanceof Error ? error.message : 'Unknown error' \n          };\n        }\n      }\n\n      // Send to webhooks if enabled\n      if (this.config.webhooks?.enabled) {\n        try {\n          await this.sendWebhooks(event);\n          results.webhooks = { success: true };\n        } catch (error) {\n          results.webhooks = { \n            success: false, \n            error: error instanceof Error ? error.message : 'Unknown error' \n          };\n        }\n      }\n\n      const allSuccessful = Object.values(results).every(r => r.success);\n      \n      return {\n        success: allSuccessful,\n        results\n      };\n\n    } catch (error) {\n      console.error('Notification sending failed:', error);\n      return {\n        success: false,\n        results: {\n          error: { \n            success: false, \n            error: error instanceof Error ? error.message : 'Unknown error' \n          }\n        }\n      };\n    }\n  }\n\n  /**\n   * Send email notification\n   */\n  private async sendEmail(event: NotificationEvent): Promise<void> {\n    if (!this.config.email?.enabled) return;\n\n    const template = this.generateEmailTemplate(event);\n    \n    // Mock email sending (in real implementation would use nodemailer or similar)\n    console.log(`üìß Email notification sent:`);\n    console.log(`To: recipient@example.com`);\n    console.log(`Subject: ${template.subject}`);\n    console.log(`Body: ${template.textBody}`);\n    \n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 100));\n  }\n\n  /**\n   * Send Slack notification\n   */\n  private async sendSlack(event: NotificationEvent): Promise<void> {\n    if (!this.config.slack?.enabled || !this.config.slack.webhookUrl) return;\n\n    const slackMessage = this.generateSlackMessage(event);\n    \n    const response = await fetch(this.config.slack.webhookUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(slackMessage)\n    });\n\n    if (!response.ok) {\n      throw new Error(`Slack webhook failed: ${response.status} ${response.statusText}`);\n    }\n\n    console.log(`üí¨ Slack notification sent to ${this.config.slack.channel}`);\n  }\n\n  /**\n   * Send webhook notifications\n   */\n  private async sendWebhooks(event: NotificationEvent): Promise<void> {\n    if (!this.config.webhooks?.enabled || !this.config.webhooks.endpoints) return;\n\n    const webhookPayload = {\n      event: event.type,\n      title: event.title,\n      message: event.message,\n      severity: event.severity,\n      timestamp: event.timestamp,\n      data: event.data\n    };\n\n    const promises = this.config.webhooks.endpoints\n      .filter(endpoint => endpoint.events.includes(event.type))\n      .map(async (endpoint) => {\n        try {\n          const headers: Record<string, string> = {\n            'Content-Type': 'application/json',\n            'User-Agent': 'NeRF-Edge-Kit/1.0.0'\n          };\n\n          // Add signature if secret is provided\n          if (endpoint.secret) {\n            const signature = await this.generateWebhookSignature(\n              JSON.stringify(webhookPayload),\n              endpoint.secret\n            );\n            headers['X-Webhook-Signature'] = signature;\n          }\n\n          const response = await fetch(endpoint.url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(webhookPayload)\n          });\n\n          if (!response.ok) {\n            throw new Error(`Webhook ${endpoint.name} failed: ${response.status}`);\n          }\n\n          console.log(`üîó Webhook sent to ${endpoint.name}`);\n\n        } catch (error) {\n          console.error(`Failed to send webhook to ${endpoint.name}:`, error);\n          throw error;\n        }\n      });\n\n    await Promise.all(promises);\n  }\n\n  /**\n   * Generate email template for event\n   */\n  private generateEmailTemplate(event: NotificationEvent): EmailTemplate {\n    const severityEmoji = {\n      info: '‚ÑπÔ∏è',\n      warning: '‚ö†Ô∏è',\n      error: '‚ùå',\n      success: '‚úÖ'\n    };\n\n    const subject = `${severityEmoji[event.severity]} NeRF Edge Kit: ${event.title}`;\n    \n    const textBody = `\n${event.title}\n\n${event.message}\n\nTimestamp: ${new Date(event.timestamp).toISOString()}\nSeverity: ${event.severity.toUpperCase()}\n\n${event.data ? `Additional Data:\\n${JSON.stringify(event.data, null, 2)}` : ''}\n\n---\nNeRF Edge Kit Notification Service\n    `.trim();\n\n    const htmlBody = `\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>${subject}</title>\n  <style>\n    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }\n    .header { background: #f4f4f4; padding: 20px; border-radius: 5px; }\n    .severity-${event.severity} { border-left: 4px solid ${this.getSeverityColor(event.severity)}; padding-left: 10px; }\n    .data { background: #f9f9f9; padding: 10px; border-radius: 3px; font-family: monospace; }\n    .footer { margin-top: 20px; font-size: 12px; color: #666; }\n  </style>\n</head>\n<body>\n  <div class=\"header severity-${event.severity}\">\n    <h2>${severityEmoji[event.severity]} ${event.title}</h2>\n  </div>\n  \n  <p>${event.message}</p>\n  \n  <p><strong>Timestamp:</strong> ${new Date(event.timestamp).toLocaleString()}</p>\n  <p><strong>Severity:</strong> ${event.severity.toUpperCase()}</p>\n  \n  ${event.data ? `\n  <h3>Additional Data:</h3>\n  <div class=\"data\">${JSON.stringify(event.data, null, 2)}</div>\n  ` : ''}\n  \n  <div class=\"footer\">\n    <p>NeRF Edge Kit Notification Service</p>\n  </div>\n</body>\n</html>\n    `.trim();\n\n    return { subject, htmlBody, textBody };\n  }\n\n  /**\n   * Generate Slack message for event\n   */\n  private generateSlackMessage(event: NotificationEvent): any {\n    const severityEmoji = {\n      info: ':information_source:',\n      warning: ':warning:',\n      error: ':x:',\n      success: ':white_check_mark:'\n    };\n\n    const severityColor = {\n      info: '#36a64f',\n      warning: '#ff9500',\n      error: '#ff0000',\n      success: '#36a64f'\n    };\n\n    return {\n      channel: this.config.slack?.channel,\n      username: this.config.slack?.username || 'NeRF Edge Kit',\n      icon_emoji: this.config.slack?.iconEmoji || ':robot_face:',\n      attachments: [\n        {\n          color: severityColor[event.severity],\n          title: `${severityEmoji[event.severity]} ${event.title}`,\n          text: event.message,\n          fields: [\n            {\n              title: 'Severity',\n              value: event.severity.toUpperCase(),\n              short: true\n            },\n            {\n              title: 'Timestamp',\n              value: new Date(event.timestamp).toISOString(),\n              short: true\n            }\n          ],\n          footer: 'NeRF Edge Kit',\n          ts: Math.floor(event.timestamp / 1000)\n        }\n      ]\n    };\n  }\n\n  /**\n   * Generate webhook signature for security\n   */\n  private async generateWebhookSignature(payload: string, secret: string): Promise<string> {\n    // Simple HMAC signature (in real implementation would use crypto.createHmac)\n    const encoder = new TextEncoder();\n    const data = encoder.encode(payload);\n    const key = encoder.encode(secret);\n    \n    // Mock signature generation\n    const mockSignature = btoa(payload + secret).substring(0, 32);\n    return `sha256=${mockSignature}`;\n  }\n\n  /**\n   * Get color for severity level\n   */\n  private getSeverityColor(severity: string): string {\n    const colors = {\n      info: '#2196F3',\n      warning: '#FF9800',\n      error: '#F44336',\n      success: '#4CAF50'\n    };\n    return colors[severity as keyof typeof colors] || colors.info;\n  }\n\n  /**\n   * Process notification queue\n   */\n  private async processQueue(): Promise<void> {\n    if (this.processing || this.queue.length === 0) return;\n    \n    this.processing = true;\n    \n    try {\n      while (this.queue.length > 0) {\n        const event = this.queue.shift()!;\n        console.log(`Processing notification: ${event.type} - ${event.title}`);\n        \n        // Add small delay to prevent overwhelming services\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n    } finally {\n      this.processing = false;\n    }\n  }\n\n  /**\n   * Send model upload notification\n   */\n  async notifyModelUploaded(modelId: string, modelName: string, size: number): Promise<void> {\n    await this.notify({\n      type: 'model_uploaded',\n      title: 'New NeRF Model Uploaded',\n      message: `Model \"${modelName}\" (${modelId}) has been successfully uploaded. Size: ${(size / 1024 / 1024).toFixed(1)}MB`,\n      severity: 'success',\n      timestamp: Date.now(),\n      data: {\n        modelId,\n        modelName,\n        size\n      }\n    });\n  }\n\n  /**\n   * Send training completion notification\n   */\n  async notifyTrainingComplete(modelId: string, duration: number, finalLoss: number): Promise<void> {\n    await this.notify({\n      type: 'training_complete',\n      title: 'NeRF Training Complete',\n      message: `Model training completed successfully. Duration: ${Math.round(duration / 1000)}s, Final Loss: ${finalLoss.toFixed(6)}`,\n      severity: 'success',\n      timestamp: Date.now(),\n      data: {\n        modelId,\n        duration,\n        finalLoss\n      }\n    });\n  }\n\n  /**\n   * Send performance alert\n   */\n  async notifyPerformanceAlert(metric: string, value: number, threshold: number): Promise<void> {\n    await this.notify({\n      type: 'performance_alert',\n      title: 'Performance Alert',\n      message: `${metric} has exceeded threshold: ${value} > ${threshold}`,\n      severity: 'warning',\n      timestamp: Date.now(),\n      data: {\n        metric,\n        value,\n        threshold\n      }\n    });\n  }\n\n  /**\n   * Send error notification\n   */\n  async notifyError(error: Error, context?: string): Promise<void> {\n    await this.notify({\n      type: 'error',\n      title: 'System Error',\n      message: `An error occurred${context ? ` in ${context}` : ''}: ${error.message}`,\n      severity: 'error',\n      timestamp: Date.now(),\n      data: {\n        error: error.message,\n        stack: error.stack,\n        context\n      }\n    });\n  }\n\n  /**\n   * Get notification statistics\n   */\n  getStats(): {\n    queueLength: number;\n    processing: boolean;\n    enabledChannels: string[];\n  } {\n    const enabledChannels = [];\n    if (this.config.email?.enabled) enabledChannels.push('email');\n    if (this.config.slack?.enabled) enabledChannels.push('slack');\n    if (this.config.webhooks?.enabled) enabledChannels.push('webhooks');\n    \n    return {\n      queueLength: this.queue.length,\n      processing: this.processing,\n      enabledChannels\n    };\n  }\n\n  /**\n   * Test all notification channels\n   */\n  async testNotifications(): Promise<Record<string, { success: boolean; error?: string }>> {\n    const testEvent: NotificationEvent = {\n      type: 'system_status',\n      title: 'Notification Test',\n      message: 'This is a test notification to verify all channels are working correctly.',\n      severity: 'info',\n      timestamp: Date.now(),\n      data: {\n        test: true\n      }\n    };\n\n    const result = await this.notify(testEvent);\n    return result.results;\n  }\n}