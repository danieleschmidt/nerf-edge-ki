/**\n * GitHub API integration for model versioning and collaboration\n */\n\nexport interface GitHubConfig {\n  apiToken: string;\n  owner: string;\n  repo: string;\n  branch?: string;\n}\n\nexport interface GitHubRelease {\n  id: number;\n  tag_name: string;\n  name: string;\n  body: string;\n  created_at: string;\n  published_at: string;\n  assets: GitHubAsset[];\n}\n\nexport interface GitHubAsset {\n  id: number;\n  name: string;\n  size: number;\n  download_count: number;\n  browser_download_url: string;\n}\n\nexport interface ModelVersion {\n  version: string;\n  modelId: string;\n  downloadUrl: string;\n  size: number;\n  checksum: string;\n  releaseNotes: string;\n  publishedAt: string;\n}\n\nexport class GitHubIntegration {\n  private config: GitHubConfig;\n  private baseUrl = 'https://api.github.com';\n\n  constructor(config: GitHubConfig) {\n    this.config = config;\n  }\n\n  /**\n   * List available model versions from GitHub releases\n   */\n  async listModelVersions(): Promise<ModelVersion[]> {\n    try {\n      const response = await fetch(\n        `${this.baseUrl}/repos/${this.config.owner}/${this.config.repo}/releases`,\n        {\n          headers: {\n            'Authorization': `Bearer ${this.config.apiToken}`,\n            'Accept': 'application/vnd.github.v3+json',\n            'X-GitHub-Api-Version': '2022-11-28'\n          }\n        }\n      );\n\n      if (!response.ok) {\n        throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);\n      }\n\n      const releases: GitHubRelease[] = await response.json();\n      \n      return releases\n        .filter(release => release.assets.some(asset => asset.name.endsWith('.nerf')))\n        .map(release => {\n          const nerfAsset = release.assets.find(asset => asset.name.endsWith('.nerf'))!;\n          \n          return {\n            version: release.tag_name,\n            modelId: nerfAsset.name.replace('.nerf', ''),\n            downloadUrl: nerfAsset.browser_download_url,\n            size: nerfAsset.size,\n            checksum: '', // Would be in release notes or separate file\n            releaseNotes: release.body || '',\n            publishedAt: release.published_at\n          };\n        })\n        .sort((a, b) => new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime());\n\n    } catch (error) {\n      console.error('Failed to list model versions:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Download a specific model version\n   */\n  async downloadModelVersion(version: ModelVersion): Promise<ArrayBuffer> {\n    try {\n      const response = await fetch(version.downloadUrl, {\n        headers: {\n          'Authorization': `Bearer ${this.config.apiToken}`,\n          'Accept': 'application/octet-stream'\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to download model: ${response.status} ${response.statusText}`);\n      }\n\n      const data = await response.arrayBuffer();\n      \n      // Verify size\n      if (data.byteLength !== version.size) {\n        throw new Error(`Size mismatch: expected ${version.size}, got ${data.byteLength}`);\n      }\n\n      console.log(`Downloaded model ${version.modelId} v${version.version} (${(data.byteLength / 1024 / 1024).toFixed(1)}MB)`);\n      return data;\n\n    } catch (error) {\n      console.error(`Failed to download model version ${version.version}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Upload a model as a new release\n   */\n  async publishModelVersion(\n    modelId: string,\n    version: string,\n    modelData: ArrayBuffer,\n    releaseNotes: string = ''\n  ): Promise<GitHubRelease> {\n    try {\n      // 1. Create the release\n      const createReleaseResponse = await fetch(\n        `${this.baseUrl}/repos/${this.config.owner}/${this.config.repo}/releases`,\n        {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${this.config.apiToken}`,\n            'Accept': 'application/vnd.github.v3+json',\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            tag_name: version,\n            name: `${modelId} v${version}`,\n            body: releaseNotes || `NeRF model ${modelId} version ${version}`,\n            draft: false,\n            prerelease: version.includes('beta') || version.includes('alpha')\n          })\n        }\n      );\n\n      if (!createReleaseResponse.ok) {\n        throw new Error(`Failed to create release: ${createReleaseResponse.status}`);\n      }\n\n      const release: GitHubRelease = await createReleaseResponse.json();\n\n      // 2. Upload the model file as an asset\n      const uploadResponse = await fetch(\n        `https://uploads.github.com/repos/${this.config.owner}/${this.config.repo}/releases/${release.id}/assets?name=${modelId}.nerf`,\n        {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${this.config.apiToken}`,\n            'Accept': 'application/vnd.github.v3+json',\n            'Content-Type': 'application/octet-stream'\n          },\n          body: modelData\n        }\n      );\n\n      if (!uploadResponse.ok) {\n        throw new Error(`Failed to upload model asset: ${uploadResponse.status}`);\n      }\n\n      console.log(`Published model ${modelId} v${version} to GitHub`);\n      return release;\n\n    } catch (error) {\n      console.error(`Failed to publish model version:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get latest model version\n   */\n  async getLatestModelVersion(modelId?: string): Promise<ModelVersion | null> {\n    const versions = await this.listModelVersions();\n    \n    if (modelId) {\n      return versions.find(v => v.modelId === modelId) || null;\n    }\n    \n    return versions[0] || null;\n  }\n\n  /**\n   * Check for model updates\n   */\n  async checkForUpdates(currentVersions: Record<string, string>): Promise<{\n    updates: Array<{ modelId: string; currentVersion: string; latestVersion: string; size: number }>;\n    hasUpdates: boolean;\n  }> {\n    const availableVersions = await this.listModelVersions();\n    const updates = [];\n\n    for (const [modelId, currentVersion] of Object.entries(currentVersions)) {\n      const latestVersion = availableVersions.find(v => v.modelId === modelId);\n      \n      if (latestVersion && latestVersion.version !== currentVersion) {\n        updates.push({\n          modelId,\n          currentVersion,\n          latestVersion: latestVersion.version,\n          size: latestVersion.size\n        });\n      }\n    }\n\n    return {\n      updates,\n      hasUpdates: updates.length > 0\n    };\n  }\n\n  /**\n   * Sync models with GitHub repository\n   */\n  async syncModels(\n    localModels: Record<string, { version: string; lastSync: number }>,\n    onProgress?: (progress: { current: number; total: number; modelId: string }) => void\n  ): Promise<{\n    downloaded: string[];\n    updated: string[];\n    skipped: string[];\n    errors: Array<{ modelId: string; error: string }>;\n  }> {\n    const result = {\n      downloaded: [] as string[],\n      updated: [] as string[],\n      skipped: [] as string[],\n      errors: [] as Array<{ modelId: string; error: string }>\n    };\n\n    try {\n      const availableVersions = await this.listModelVersions();\n      \n      for (let i = 0; i < availableVersions.length; i++) {\n        const version = availableVersions[i];\n        const localModel = localModels[version.modelId];\n        \n        if (onProgress) {\n          onProgress({\n            current: i + 1,\n            total: availableVersions.length,\n            modelId: version.modelId\n          });\n        }\n\n        try {\n          if (!localModel) {\n            // New model - download it\n            await this.downloadModelVersion(version);\n            result.downloaded.push(version.modelId);\n          } else if (localModel.version !== version.version) {\n            // Updated model - download new version\n            await this.downloadModelVersion(version);\n            result.updated.push(version.modelId);\n          } else {\n            // Same version - skip\n            result.skipped.push(version.modelId);\n          }\n        } catch (error) {\n          result.errors.push({\n            modelId: version.modelId,\n            error: error instanceof Error ? error.message : 'Unknown error'\n          });\n        }\n      }\n\n    } catch (error) {\n      console.error('Failed to sync models:', error);\n      throw error;\n    }\n\n    return result;\n  }\n\n  /**\n   * Get repository information\n   */\n  async getRepositoryInfo(): Promise<{\n    name: string;\n    description: string;\n    stars: number;\n    forks: number;\n    lastUpdated: string;\n    topics: string[];\n  }> {\n    try {\n      const response = await fetch(\n        `${this.baseUrl}/repos/${this.config.owner}/${this.config.repo}`,\n        {\n          headers: {\n            'Authorization': `Bearer ${this.config.apiToken}`,\n            'Accept': 'application/vnd.github.v3+json'\n          }\n        }\n      );\n\n      if (!response.ok) {\n        throw new Error(`Failed to get repository info: ${response.status}`);\n      }\n\n      const repo = await response.json();\n      \n      return {\n        name: repo.name,\n        description: repo.description || '',\n        stars: repo.stargazers_count,\n        forks: repo.forks_count,\n        lastUpdated: repo.updated_at,\n        topics: repo.topics || []\n      };\n\n    } catch (error) {\n      console.error('Failed to get repository info:', error);\n      throw error;\n    }\n  }\n}