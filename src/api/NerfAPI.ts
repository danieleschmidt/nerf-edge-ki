/**
 * RESTful API interface for NeRF Edge Kit
 * Provides HTTP endpoints for model management and rendering
 */

import { NerfService, ModelOptimizationOptions, TrainingConfig } from '../services/NerfService';\nimport { PerformanceService } from '../services/PerformanceService';\nimport { ModelRepository, ModelCreateRequest, ModelQuery } from '../repositories/ModelRepository';\nimport { NerfRenderer } from '../rendering/NerfRenderer';\nimport { RenderOptions } from '../core/types';\n\nexport interface APIResponse<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  timestamp: number;\n  requestId: string;\n}\n\nexport interface APIConfig {\n  enableCORS: boolean;\n  maxRequestSize: number; // bytes\n  rateLimit: {\n    windowMs: number;\n    maxRequests: number;\n  };\n  authentication?: {\n    enabled: boolean;\n    apiKeyHeader: string;\n    validApiKeys: string[];\n  };\n}\n\nexport class NerfAPI {\n  private service: NerfService;\n  private performance: PerformanceService;\n  private repository: ModelRepository;\n  private renderer: NerfRenderer | null = null;\n  private config: APIConfig;\n  private requestCount: Map<string, { count: number; resetTime: number }> = new Map();\n\n  constructor(config: Partial<APIConfig> = {}) {\n    this.config = {\n      enableCORS: true,\n      maxRequestSize: 100 * 1024 * 1024, // 100MB\n      rateLimit: {\n        windowMs: 60 * 1000, // 1 minute\n        maxRequests: 100\n      },\n      ...config\n    };\n\n    this.service = new NerfService();\n    this.performance = new PerformanceService();\n    this.repository = new ModelRepository();\n  }\n\n  /**\n   * Initialize the API\n   */\n  async initialize(): Promise<void> {\n    await this.repository.initialize();\n    console.log('NeRF API initialized');\n  }\n\n  /**\n   * Set renderer instance for rendering endpoints\n   */\n  setRenderer(renderer: NerfRenderer): void {\n    this.renderer = renderer;\n  }\n\n  // Model Management Endpoints\n\n  /**\n   * POST /api/models\n   * Upload and create a new NeRF model\n   */\n  async createModel(request: {\n    name: string;\n    data: ArrayBuffer;\n    quality?: 'low' | 'medium' | 'high';\n    tags?: string[];\n    metadata?: Record<string, any>;\n  }): Promise<APIResponse<{ id: string; model: any }>> {\n    const requestId = this.generateRequestId();\n    \n    try {\n      // Validate request size\n      if (request.data.byteLength > this.config.maxRequestSize) {\n        return this.errorResponse('Model data exceeds maximum size limit', requestId);\n      }\n\n      // Create model in repository\n      const modelId = await this.repository.create({\n        name: request.name,\n        data: request.data,\n        quality: request.quality,\n        tags: request.tags,\n        metadata: request.metadata\n      });\n\n      // Load model in service for analysis\n      const model = await this.service.loadModel(request.data, modelId);\n      const metrics = await this.service.analyzeModel(modelId);\n\n      return this.successResponse({\n        id: modelId,\n        model: {\n          id: modelId,\n          name: request.name,\n          quality: request.quality || 'medium',\n          size: request.data.byteLength,\n          metrics\n        }\n      }, requestId);\n\n    } catch (error) {\n      return this.errorResponse(error instanceof Error ? error.message : 'Unknown error', requestId);\n    }\n  }\n\n  /**\n   * GET /api/models\n   * List models with optional filtering\n   */\n  async listModels(query: ModelQuery = {}): Promise<APIResponse<{ models: any[]; total: number }>> {\n    const requestId = this.generateRequestId();\n    \n    try {\n      const models = await this.repository.find(query);\n      const total = models.length;\n\n      const modelData = models.map(model => ({\n        id: model.id,\n        name: model.name,\n        quality: model.metadata.quality,\n        size: model.metadata.size,\n        created: model.metadata.created,\n        modified: model.metadata.modified,\n        tags: model.metadata.tags,\n        performance: model.performance\n      }));\n\n      return this.successResponse({ models: modelData, total }, requestId);\n\n    } catch (error) {\n      return this.errorResponse(error instanceof Error ? error.message : 'Unknown error', requestId);\n    }\n  }\n\n  /**\n   * GET /api/models/:id\n   * Get specific model details\n   */\n  async getModel(id: string): Promise<APIResponse<any>> {\n    const requestId = this.generateRequestId();\n    \n    try {\n      const storedModel = await this.repository.findById(id);\n      if (!storedModel) {\n        return this.errorResponse('Model not found', requestId, 404);\n      }\n\n      const modelData = {\n        id: storedModel.id,\n        name: storedModel.name,\n        quality: storedModel.metadata.quality,\n        size: storedModel.metadata.size,\n        created: storedModel.metadata.created,\n        modified: storedModel.metadata.modified,\n        tags: storedModel.metadata.tags,\n        metadata: storedModel.metadata,\n        performance: storedModel.performance\n      };\n\n      return this.successResponse(modelData, requestId);\n\n    } catch (error) {\n      return this.errorResponse(error instanceof Error ? error.message : 'Unknown error', requestId);\n    }\n  }\n\n  /**\n   * PUT /api/models/:id\n   * Update model metadata\n   */\n  async updateModel(id: string, updates: {\n    name?: string;\n    quality?: 'low' | 'medium' | 'high';\n    tags?: string[];\n    metadata?: Record<string, any>;\n  }): Promise<APIResponse<{ success: boolean }>> {\n    const requestId = this.generateRequestId();\n    \n    try {\n      const success = await this.repository.update(id, updates);\n      if (!success) {\n        return this.errorResponse('Model not found', requestId, 404);\n      }\n\n      return this.successResponse({ success: true }, requestId);\n\n    } catch (error) {\n      return this.errorResponse(error instanceof Error ? error.message : 'Unknown error', requestId);\n    }\n  }\n\n  /**\n   * DELETE /api/models/:id\n   * Delete a model\n   */\n  async deleteModel(id: string): Promise<APIResponse<{ success: boolean }>> {\n    const requestId = this.generateRequestId();\n    \n    try {\n      const success = await this.repository.delete(id);\n      if (!success) {\n        return this.errorResponse('Model not found', requestId, 404);\n      }\n\n      return this.successResponse({ success: true }, requestId);\n\n    } catch (error) {\n      return this.errorResponse(error instanceof Error ? error.message : 'Unknown error', requestId);\n    }\n  }\n\n  // Model Operations\n\n  /**\n   * POST /api/models/:id/optimize\n   * Optimize model for specific device\n   */\n  async optimizeModel(id: string, options: ModelOptimizationOptions): Promise<APIResponse<{ optimizedId: string; metrics: any }>> {\n    const requestId = this.generateRequestId();\n    \n    try {\n      const optimizedModel = await this.service.optimizeModel(id, options);\n      const metrics = await this.service.analyzeModel(id);\n\n      return this.successResponse({\n        optimizedId: id, // In real implementation, would be a new ID\n        metrics\n      }, requestId);\n\n    } catch (error) {\n      return this.errorResponse(error instanceof Error ? error.message : 'Unknown error', requestId);\n    }\n  }\n\n  /**\n   * POST /api/models/:id/analyze\n   * Analyze model performance characteristics\n   */\n  async analyzeModel(id: string): Promise<APIResponse<any>> {\n    const requestId = this.generateRequestId();\n    \n    try {\n      const metrics = await this.service.analyzeModel(id);\n      return this.successResponse(metrics, requestId);\n\n    } catch (error) {\n      return this.errorResponse(error instanceof Error ? error.message : 'Unknown error', requestId);\n    }\n  }\n\n  /**\n   * POST /api/train\n   * Train new model from point cloud data\n   */\n  async trainModel(request: {\n    data: ArrayBuffer;\n    config: TrainingConfig;\n  }): Promise<APIResponse<{ modelId: string; progress: number }>> {\n    const requestId = this.generateRequestId();\n    \n    try {\n      // Start training (this would typically be async with progress updates)\n      const trainedModel = await this.service.trainModel(\n        request.data,\n        request.config,\n        (progress) => {\n          // In a real implementation, would use WebSocket or polling for progress\n          console.log(`Training progress: ${(progress * 100).toFixed(1)}%`);\n        }\n      );\n\n      // Store trained model\n      const modelId = await this.repository.create({\n        name: `Trained Model ${Date.now()}`,\n        data: new ArrayBuffer(1024), // Would be actual trained model data\n        quality: 'medium',\n        tags: ['trained'],\n        metadata: {\n          trainingConfig: request.config,\n          trained: true\n        }\n      });\n\n      return this.successResponse({\n        modelId,\n        progress: 1.0\n      }, requestId);\n\n    } catch (error) {\n      return this.errorResponse(error instanceof Error ? error.message : 'Unknown error', requestId);\n    }\n  }\n\n  // Rendering Endpoints\n\n  /**\n   * POST /api/render\n   * Render a frame with given parameters\n   */\n  async renderFrame(request: {\n    modelId: string;\n    renderOptions: RenderOptions;\n    outputFormat?: 'png' | 'jpeg' | 'webp';\n  }): Promise<APIResponse<{ imageData: string; renderTime: number }>> {\n    const requestId = this.generateRequestId();\n    \n    try {\n      if (!this.renderer) {\n        return this.errorResponse('Renderer not initialized', requestId, 503);\n      }\n\n      // Get model from repository\n      const model = await this.repository.getModel(request.modelId);\n      if (!model) {\n        return this.errorResponse('Model not found', requestId, 404);\n      }\n\n      // Render frame (mock implementation)\n      const startTime = performance.now();\n      \n      // In real implementation, would render and capture frame\n      const mockImageData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==';\n      \n      const renderTime = performance.now() - startTime;\n\n      return this.successResponse({\n        imageData: mockImageData,\n        renderTime\n      }, requestId);\n\n    } catch (error) {\n      return this.errorResponse(error instanceof Error ? error.message : 'Unknown error', requestId);\n    }\n  }\n\n  // Performance and Monitoring\n\n  /**\n   * GET /api/performance\n   * Get current performance metrics\n   */\n  async getPerformanceMetrics(): Promise<APIResponse<any>> {\n    const requestId = this.generateRequestId();\n    \n    try {\n      const stats = this.performance.getCurrentStats();\n      const percentiles = this.performance.getPercentiles();\n      const recommendations = this.performance.getRecommendations();\n\n      return this.successResponse({\n        stats,\n        percentiles,\n        recommendations\n      }, requestId);\n\n    } catch (error) {\n      return this.errorResponse(error instanceof Error ? error.message : 'Unknown error', requestId);\n    }\n  }\n\n  /**\n   * POST /api/benchmark\n   * Run performance benchmark\n   */\n  async runBenchmark(request: {\n    testName: string;\n    duration: number;\n    modelId?: string;\n  }): Promise<APIResponse<any>> {\n    const requestId = this.generateRequestId();\n    \n    try {\n      const mockMetricsProvider = () => ({\n        fps: 60 + Math.random() * 30,\n        frameTime: 16.7 + Math.random() * 10,\n        gpuUtilization: 0.5 + Math.random() * 0.4,\n        memoryUsage: 300 + Math.random() * 200,\n        powerConsumption: 4 + Math.random() * 4\n      });\n\n      const result = await this.performance.runBenchmark(\n        request.testName,\n        request.duration,\n        mockMetricsProvider\n      );\n\n      return this.successResponse(result, requestId);\n\n    } catch (error) {\n      return this.errorResponse(error instanceof Error ? error.message : 'Unknown error', requestId);\n    }\n  }\n\n  /**\n   * GET /api/stats\n   * Get system statistics\n   */\n  async getSystemStats(): Promise<APIResponse<any>> {\n    const requestId = this.generateRequestId();\n    \n    try {\n      const modelStats = await this.repository.getStats();\n      const cacheStats = this.service.getCacheStats();\n      const performanceData = this.performance.exportData();\n\n      return this.successResponse({\n        models: modelStats,\n        cache: cacheStats,\n        performance: {\n          current: performanceData.stats,\n          profile: performanceData.profile\n        },\n        system: {\n          uptime: process?.uptime?.() || 0,\n          memory: this.getMemoryUsage(),\n          timestamp: Date.now()\n        }\n      }, requestId);\n\n    } catch (error) {\n      return this.errorResponse(error instanceof Error ? error.message : 'Unknown error', requestId);\n    }\n  }\n\n  // Utility methods\n\n  private generateRequestId(): string {\n    return `req_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;\n  }\n\n  private successResponse<T>(data: T, requestId: string): APIResponse<T> {\n    return {\n      success: true,\n      data,\n      timestamp: Date.now(),\n      requestId\n    };\n  }\n\n  private errorResponse(error: string, requestId: string, statusCode?: number): APIResponse {\n    return {\n      success: false,\n      error,\n      timestamp: Date.now(),\n      requestId\n    };\n  }\n\n  private checkRateLimit(clientId: string): boolean {\n    const now = Date.now();\n    const clientData = this.requestCount.get(clientId);\n    \n    if (!clientData || now > clientData.resetTime) {\n      this.requestCount.set(clientId, {\n        count: 1,\n        resetTime: now + this.config.rateLimit.windowMs\n      });\n      return true;\n    }\n    \n    if (clientData.count >= this.config.rateLimit.maxRequests) {\n      return false;\n    }\n    \n    clientData.count++;\n    return true;\n  }\n\n  private getMemoryUsage(): any {\n    if (typeof process !== 'undefined' && process.memoryUsage) {\n      const usage = process.memoryUsage();\n      return {\n        rss: Math.round(usage.rss / 1024 / 1024), // MB\n        heapTotal: Math.round(usage.heapTotal / 1024 / 1024),\n        heapUsed: Math.round(usage.heapUsed / 1024 / 1024),\n        external: Math.round(usage.external / 1024 / 1024)\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Middleware for rate limiting\n   */\n  rateLimit(clientId: string): boolean {\n    return this.checkRateLimit(clientId);\n  }\n\n  /**\n   * Middleware for authentication\n   */\n  authenticate(apiKey: string): boolean {\n    if (!this.config.authentication?.enabled) {\n      return true;\n    }\n    \n    return this.config.authentication.validApiKeys.includes(apiKey);\n  }\n\n  /**\n   * Dispose of API resources\n   */\n  dispose(): void {\n    this.service.dispose();\n    this.performance.dispose();\n    this.repository.dispose();\n    this.requestCount.clear();\n    console.log('NeRF API disposed');\n  }\n}