/**\n * Web Worker for NeRF computations to keep main thread responsive\n */\n\nimport { NerfModel } from '../core/NerfModel';\nimport { PerformanceMetrics } from '../core/types';\n\nexport interface WorkerMessage {\n  id: string;\n  type: 'load_model' | 'optimize_model' | 'train_model' | 'render_frame' | 'benchmark';\n  data: any;\n}\n\nexport interface WorkerResponse {\n  id: string;\n  type: 'success' | 'error' | 'progress';\n  data?: any;\n  error?: string;\n  progress?: number;\n}\n\nclass NerfWorker {\n  private models: Map<string, NerfModel> = new Map();\n  private currentTask: string | null = null;\n\n  constructor() {\n    self.onmessage = this.handleMessage.bind(this);\n    this.postMessage({\n      id: 'init',\n      type: 'success',\n      data: { message: 'NeRF Worker initialized' }\n    });\n  }\n\n  private handleMessage(event: MessageEvent<WorkerMessage>): void {\n    const { id, type, data } = event.data;\n    this.currentTask = id;\n\n    try {\n      switch (type) {\n        case 'load_model':\n          this.loadModel(id, data);\n          break;\n        case 'optimize_model':\n          this.optimizeModel(id, data);\n          break;\n        case 'train_model':\n          this.trainModel(id, data);\n          break;\n        case 'render_frame':\n          this.renderFrame(id, data);\n          break;\n        case 'benchmark':\n          this.runBenchmark(id, data);\n          break;\n        default:\n          this.postError(id, `Unknown message type: ${type}`);\n      }\n    } catch (error) {\n      this.postError(id, error instanceof Error ? error.message : 'Unknown error');\n    }\n  }\n\n  private async loadModel(id: string, data: { modelId: string; modelData: ArrayBuffer }): Promise<void> {\n    try {\n      const model = new NerfModel();\n      await model.load(data.modelData);\n      \n      this.models.set(data.modelId, model);\n      \n      this.postMessage({\n        id,\n        type: 'success',\n        data: {\n          modelId: data.modelId,\n          loaded: true,\n          memoryUsage: model.getMemoryUsage()\n        }\n      });\n    } catch (error) {\n      this.postError(id, `Failed to load model: ${error}`);\n    }\n  }\n\n  private async optimizeModel(id: string, data: {\n    modelId: string;\n    options: any;\n  }): Promise<void> {\n    try {\n      const model = this.models.get(data.modelId);\n      if (!model) {\n        throw new Error(`Model ${data.modelId} not found`);\n      }\n\n      // Simulate optimization process with progress updates\n      const steps = 10;\n      for (let i = 0; i < steps; i++) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n        \n        this.postMessage({\n          id,\n          type: 'progress',\n          progress: (i + 1) / steps\n        });\n      }\n\n      // Create optimized version (mock)\n      const optimizedModel = NerfModel.createMockModel();\n      const optimizedId = `${data.modelId}_optimized`;\n      this.models.set(optimizedId, optimizedModel);\n\n      this.postMessage({\n        id,\n        type: 'success',\n        data: {\n          originalId: data.modelId,\n          optimizedId,\n          memoryReduction: model.getMemoryUsage() - optimizedModel.getMemoryUsage()\n        }\n      });\n    } catch (error) {\n      this.postError(id, `Optimization failed: ${error}`);\n    }\n  }\n\n  private async trainModel(id: string, data: {\n    pointCloudData: ArrayBuffer;\n    config: any;\n  }): Promise<void> {\n    try {\n      const totalIterations = data.config.iterations || 1000;\n      const progressInterval = Math.max(1, Math.floor(totalIterations / 100));\n\n      // Simulate training process\n      for (let iteration = 0; iteration < totalIterations; iteration++) {\n        // Simulate computation time\n        await new Promise(resolve => setTimeout(resolve, 1));\n        \n        // Send progress updates\n        if (iteration % progressInterval === 0) {\n          this.postMessage({\n            id,\n            type: 'progress',\n            progress: iteration / totalIterations,\n            data: {\n              iteration,\n              loss: 1.0 - (iteration / totalIterations) * 0.8 + Math.random() * 0.1\n            }\n          });\n        }\n      }\n\n      // Create trained model\n      const trainedModel = NerfModel.createMockModel();\n      const trainedId = `trained_${Date.now()}`;\n      this.models.set(trainedId, trainedModel);\n\n      this.postMessage({\n        id,\n        type: 'success',\n        data: {\n          modelId: trainedId,\n          iterations: totalIterations,\n          finalLoss: 0.15 + Math.random() * 0.05,\n          memoryUsage: trainedModel.getMemoryUsage()\n        }\n      });\n    } catch (error) {\n      this.postError(id, `Training failed: ${error}`);\n    }\n  }\n\n  private async renderFrame(id: string, data: {\n    modelId: string;\n    cameraParams: any;\n    renderOptions: any;\n  }): Promise<void> {\n    try {\n      const model = this.models.get(data.modelId);\n      if (!model) {\n        throw new Error(`Model ${data.modelId} not found`);\n      }\n\n      // Simulate rendering computation\n      const startTime = performance.now();\n      \n      // Mock ray marching computation\n      const resolution = data.renderOptions.resolution || [800, 600];\n      const rayCount = resolution[0] * resolution[1];\n      const samplesPerRay = data.renderOptions.samples || 64;\n      const totalSamples = rayCount * samplesPerRay;\n      \n      // Simulate processing batches\n      const batchSize = 10000;\n      const batches = Math.ceil(totalSamples / batchSize);\n      \n      for (let batch = 0; batch < batches; batch++) {\n        // Simulate computation time based on complexity\n        await new Promise(resolve => setTimeout(resolve, 5));\n        \n        if (batch % 10 === 0) {\n          this.postMessage({\n            id,\n            type: 'progress',\n            progress: batch / batches\n          });\n        }\n      }\n\n      const renderTime = performance.now() - startTime;\n      \n      // Generate simple image data (1x1 pixel for demo)\n      const imageData = new Uint8ClampedArray([128, 128, 128, 255]);\n      \n      this.postMessage({\n        id,\n        type: 'success',\n        data: {\n          imageData: Array.from(imageData),\n          renderTime,\n          resolution,\n          sampleCount: totalSamples\n        }\n      });\n    } catch (error) {\n      this.postError(id, `Rendering failed: ${error}`);\n    }\n  }\n\n  private async runBenchmark(id: string, data: {\n    testName: string;\n    duration: number;\n    modelId?: string;\n  }): Promise<void> {\n    try {\n      const startTime = performance.now();\n      const endTime = startTime + data.duration * 1000;\n      const samples: PerformanceMetrics[] = [];\n      \n      while (performance.now() < endTime) {\n        // Simulate frame rendering\n        const frameStart = performance.now();\n        \n        // Mock rendering work\n        await new Promise(resolve => setTimeout(resolve, 8 + Math.random() * 8));\n        \n        const frameTime = performance.now() - frameStart;\n        const fps = 1000 / frameTime;\n        \n        samples.push({\n          fps,\n          frameTime,\n          gpuUtilization: 0.6 + Math.random() * 0.3,\n          memoryUsage: 400 + Math.random() * 100,\n          powerConsumption: 5 + Math.random() * 2\n        });\n        \n        // Send progress\n        const progress = (performance.now() - startTime) / (data.duration * 1000);\n        if (samples.length % 10 === 0) {\n          this.postMessage({\n            id,\n            type: 'progress',\n            progress: Math.min(progress, 1.0)\n          });\n        }\n      }\n      \n      // Calculate benchmark results\n      const fpsValues = samples.map(s => s.fps);\n      const frameTimeValues = samples.map(s => s.frameTime);\n      \n      const averageFPS = fpsValues.reduce((a, b) => a + b) / fpsValues.length;\n      const minFPS = Math.min(...fpsValues);\n      const maxFPS = Math.max(...fpsValues);\n      const averageFrameTime = frameTimeValues.reduce((a, b) => a + b) / frameTimeValues.length;\n      \n      this.postMessage({\n        id,\n        type: 'success',\n        data: {\n          testName: data.testName,\n          duration: data.duration,\n          sampleCount: samples.length,\n          averageFPS,\n          minFPS,\n          maxFPS,\n          averageFrameTime,\n          samples: samples.slice(-10) // Last 10 samples\n        }\n      });\n    } catch (error) {\n      this.postError(id, `Benchmark failed: ${error}`);\n    }\n  }\n\n  private postMessage(response: WorkerResponse): void {\n    (self as any).postMessage(response);\n  }\n\n  private postError(id: string, error: string): void {\n    this.postMessage({\n      id,\n      type: 'error',\n      error\n    });\n  }\n\n  // Memory management\n  private cleanup(): void {\n    for (const model of this.models.values()) {\n      model.dispose();\n    }\n    this.models.clear();\n  }\n\n  // Handle worker termination\n  private handleTerminate(): void {\n    this.cleanup();\n  }\n}\n\n// Initialize worker\nif (typeof self !== 'undefined' && self.importScripts) {\n  new NerfWorker();\n}\n\nexport default NerfWorker;